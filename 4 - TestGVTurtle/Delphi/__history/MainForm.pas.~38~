{ |========================================================================|
  |                                                                        |
  |                  G V S O F T                                           |
  |                  Projet : GVLogo                                       |
  |                  Description : Test de la tortue graphique             |
  |                  Unité : TestGVTurtles.pas                             |
  |                  Ecrit par  : VASSEUR Gilles                           |
  |                  e-mail : g.vasseur58@laposte.net                      |
  |                  Copyright : © G. VASSEUR                              |
  |                  Date:    07-07-2014 22:09:08                          |
  |                  Version : 2.0.0                                       |
  |                                                                        |
  |========================================================================| }
unit MainForm;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
  System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, GVConsts, GVTurtles, Vcl.ExtCtrls,
  Vcl.StdCtrls, Vcl.Samples.Spin, Vcl.ImgList, Vcl.ComCtrls;

type
  TMainFormGVTurtles = class(TForm)
    pnlTurtle: TPanel;
    mmoTurtle: TMemo;
    grpCommands: TGroupBox;
    btnSetPos: TButton;
    seSetPosX: TSpinEdit;
    seSetPosY: TSpinEdit;
    btnMove: TButton;
    seMove: TSpinEdit;
    btnScaleX: TButton;
    seScaleX: TSpinEdit;
    btnScaleY: TButton;
    seScaleY: TSpinEdit;
    btnTurn: TButton;
    seTurn: TSpinEdit;
    btnTowards: TButton;
    seTowardsX: TSpinEdit;
    seTowardsY: TSpinEdit;
    btnHeading: TButton;
    seHeading: TSpinEdit;
    btnSize: TButton;
    seSize: TSpinEdit;
    btnReInit: TButton;
    btnWipe: TButton;
    btnHome: TButton;
    btnTurtleVisible: TButton;
    btnPenDown: TButton;
    btnScreenColor: TButton;
    clrbxScreenColor: TColorBox;
    btnPenColor: TButton;
    clrbxPenColor: TColorBox;
    btnPenReverse: TButton;
    btnPenRubber: TButton;
    btnSaveTurtle: TButton;
    btnReloadTurtle: TButton;
    iTurtle: TImageList;
    statusbar: TStatusBar;
    btnKind: TButton;
    grpShapes: TGroupBox;
    seX1: TSpinEdit;
    seY1: TSpinEdit;
    seX2: TSpinEdit;
    seY2: TSpinEdit;
    seX3: TSpinEdit;
    seY3: TSpinEdit;
    seX4: TSpinEdit;
    seY4: TSpinEdit;
    seLen: TSpinEdit;
    btnRectangle: TButton;
    btnRectangle2: TButton;
    btnSquare: TButton;
    btnSquare2: TButton;
    btnRoundRect: TButton;
    btnRoundRect2: TButton;
    btnEllipse: TButton;
    btnEllipse2: TButton;
    btnCircle: TButton;
    btnCircle2: TButton;
    btnArc: TButton;
    btnArc2: TButton;
    btnPie: TButton;
    btnPie2: TButton;
    btnChord: TButton;
    btnChord2: TButton;
    btnFilled: TButton;
    btnExample: TButton;
    tbExample: TTrackBar;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure btnSetPosClick(Sender: TObject);
    procedure btnMoveClick(Sender: TObject);
    procedure btnScaleXClick(Sender: TObject);
    procedure btnScaleYClick(Sender: TObject);
    procedure btnTurnClick(Sender: TObject);
    procedure btnTowardsClick(Sender: TObject);
    procedure btnHeadingClick(Sender: TObject);
    procedure btnSizeClick(Sender: TObject);
    procedure btnReInitClick(Sender: TObject);
    procedure btnWipeClick(Sender: TObject);
    procedure btnHomeClick(Sender: TObject);
    procedure btnTurtleVisibleClick(Sender: TObject);
    procedure btnPenDownClick(Sender: TObject);
    procedure btnScreenColorClick(Sender: TObject);
    procedure btnPenColorClick(Sender: TObject);
    procedure btnPenReverseClick(Sender: TObject);
    procedure btnPenRubberClick(Sender: TObject);
    procedure btnSaveTurtleClick(Sender: TObject);
    procedure btnReloadTurtleClick(Sender: TObject);
    procedure btnKindClick(Sender: TObject);
    procedure btnRectangleClick(Sender: TObject);
    procedure btnFilledClick(Sender: TObject);
    procedure btnExampleClick(Sender: TObject);
    procedure tbExampleChange(Sender: TObject);
  private
    { Déclarations privées }
    GVTurtle: TGVTurtle;
  public
    { Déclarations publiques }
    // changement de fond
    procedure BkgChanged(Obj: TObject; Color: TColor);
    // message de la tortue
    procedure TurtleState(Sender: TObject; cX, cY, cHeading: Integer;
      cVisible, cDown: Boolean; cColor: TColor);
    // pour peindre la tortue
    procedure TurtleBeforePaint(Sender: TObject; cHeading: Integer);
  end;

var
  MainFormGVTurtles: TMainFormGVTurtles;

implementation

{$R *.dfm}

uses
  StrUtils;

procedure TMainFormGVTurtles.BkgChanged(Obj: TObject; Color: TColor);
begin
  pnlTurtle.Color := Color;
end;

procedure TMainFormGVTurtles.btnExampleClick(Sender: TObject);
// test d'une suite d'ordres pour GVTurtle
var
  I: Integer;

  procedure Wait;
  begin
    Application.ProcessMessages; // permet le dessin progressif
  end;

begin
  with GVTurtle do
    for I := 1 to 36 do
    begin
      // couleur au hasard
      PenColor := RGB(random(255),random(255),random(255));
      Wait;
      Move(80);
      Wait;
      Turn(90);
      Wait;
      Move(80);
      Wait;
      Turn(90);
      Wait;
      Move(80);
      Wait;
      Turn(90);
      Wait;
      Move(80);
      Wait;
      Turn(90);
      Wait;
      Turn(10);
    end;
end;

procedure TMainFormGVTurtles.btnFilledClick(Sender: TObject);
// test de FILLED
begin
  with GVTurtle do
    Filled := not Filled;
  mmoTurtle.Lines.Add('FILLED - ' + IfThen(GVTurtle.Filled, P_True, P_False));
end;

procedure TMainFormGVTurtles.btnHeadingClick(Sender: TObject);
// test de HEADING
begin
  GVTurtle.Heading := seHeading.Value;
  mmoTurtle.Lines.Add(Format('HEADING - valeur en degrés: %d',
    [seHeading.Value]));
end;

procedure TMainFormGVTurtles.btnHomeClick(Sender: TObject);
// test de HOME
begin
  GVTurtle.Home;
  mmoTurtle.Lines.Add('HOME');
end;

procedure TMainFormGVTurtles.btnReInitClick(Sender: TObject);
// test de REINIT
begin
  GVTurtle.ReInit;
  mmoTurtle.Lines.Add('REINIT');
end;

procedure TMainFormGVTurtles.btnKindClick(Sender: TObject);
// test de KIND
var
  S: string;
begin
  with GVTurtle do
    if Kind = tkTriangle then
    begin
      Kind := tkPng;
      S := 'Image PNG';
    end
    else
    begin
      Kind := tkTriangle;
      S := 'Triangle';
    end;
  mmoTurtle.Lines.Add('KIND - ' + S);
end;

procedure TMainFormGVTurtles.btnMoveClick(Sender: TObject);
// test de MOVE
begin
  GVTurtle.Move(seMove.Value);
  mmoTurtle.Lines.Add(Format('MOVE - valeur en points: %d', [seMove.Value]));
end;

procedure TMainFormGVTurtles.btnPenColorClick(Sender: TObject);
// test de CANVAS.PEN.COLOR
begin
  GVTurtle.PenColor := clrbxPenColor.Selected;;
  mmoTurtle.Lines.Add('PENCOLOR ');
end;

procedure TMainFormGVTurtles.btnPenDownClick(Sender: TObject);
// test de PENDOWN
begin
  with GVTurtle do
    PenDown := not PenDown;
  mmoTurtle.Lines.Add('PENDOWN - ' + IfThen(GVTurtle.PenDown, P_True, P_False));
end;

procedure TMainFormGVTurtles.btnPenReverseClick(Sender: TObject);
// test de PENREVERSE
begin
  with GVTurtle do
    PenReverse := not PenReverse;
  mmoTurtle.Lines.Add('PENREVERSE - ' + IfThen(GVTurtle.PenReverse, P_True,
    P_False));
end;

procedure TMainFormGVTurtles.btnPenRubberClick(Sender: TObject);
// test de PENRUBBER
begin
  with GVTurtle do
    PenRubber := not PenRubber;
  mmoTurtle.Lines.Add('PENRUBBER - ' + IfThen(GVTurtle.PenRubber, P_True,
    P_False));
end;

procedure TMainFormGVTurtles.btnRectangleClick(Sender: TObject);
// dessin de formes
begin
  with GVTurtle do
    case (Sender as TButton).Tag of
      1:
        Rectangle(seX1.Value, seY1.Value, seX2.Value, seY2.Value);
      2:
        Rectangle(seX2.Value, seY2.Value);
      3:
        Square(seX1.Value, seY1.Value, seLen.Value);
      4:
        Square(seLen.Value);
      5:
        RoundRect(seX1.Value, seY1.Value, seX2.Value, seY2.Value);
      6:
        RoundRect(seX2.Value, seY2.Value);
      7:
        Ellipse(seX1.Value, seY1.Value, seX2.Value, seY2.Value);
      8:
        Ellipse(seX2.Value, seY2.Value);
      9:
        Circle(seX1.Value, seY1.Value, seLen.Value);
      10:
        Circle(seLen.Value);
      11:
        Arc(seX1.Value, seY1.Value, seX2.Value, seY2.Value, seX3.Value,
          seY3.Value, seX4.Value, seY4.Value);
      12:
        Arc(seX2.Value, seY2.Value, seX3.Value, seY3.Value, seX4.Value,
          seY4.Value);
      13:
        Pie(seX1.Value, seY1.Value, seX2.Value, seY2.Value, seX3.Value,
          seY3.Value, seX4.Value, seY4.Value);
      14:
        Pie(seX2.Value, seY2.Value, seX3.Value, seY3.Value, seX4.Value,
          seY4.Value);
      15:
        Chord(seX1.Value, seY1.Value, seX2.Value, seY2.Value, seX3.Value,
          seY3.Value, seX4.Value, seY4.Value);
      16:
        Chord(seX2.Value, seY2.Value, seX3.Value, seY3.Value, seX4.Value,
          seY4.Value);
    end;
end;

procedure TMainFormGVTurtles.btnReloadTurtleClick(Sender: TObject);
// test de RELOADTURTLE
begin
  GVTurtle.ReloadTurtle(False);
  mmoTurtle.Lines.Add('RELOADTURTLE');
end;

procedure TMainFormGVTurtles.btnSaveTurtleClick(Sender: TObject);
// test de SAVETURTLE
begin
  GVTurtle.SaveTurtle;
  mmoTurtle.Lines.Add('SAVETURTLE');
end;

procedure TMainFormGVTurtles.btnScaleXClick(Sender: TObject);
// test de SCALEX
begin
  GVTurtle.ScaleX := seScaleX.Value;
  mmoTurtle.Lines.Add(Format('SCALEX - %d', [GVTurtle.ScaleX]));
end;

procedure TMainFormGVTurtles.btnScaleYClick(Sender: TObject);
// test de SCALEY
begin
  GVTurtle.ScaleY := seScaleY.Value;
  mmoTurtle.Lines.Add(Format('SCALEY - %d', [GVTurtle.ScaleY]));
end;

procedure TMainFormGVTurtles.btnScreenColorClick(Sender: TObject);
// test de SCREENCOLOR
begin
  GVTurtle.ScreenColor := clrbxScreenColor.Selected;
  mmoTurtle.Lines.Add('SCREENCOLOR - ');
end;

procedure TMainFormGVTurtles.btnSetPosClick(Sender: TObject);
// test de SETPOS
begin
  GVTurtle.SetPos(seSetPosX.Value, seSetPosY.Value);
  mmoTurtle.Lines.Add(Format('SETPOS - X: %d - Y: %d', [seSetPosX.Value,
    seSetPosY.Value]));
end;

procedure TMainFormGVTurtles.btnSizeClick(Sender: TObject);
// test de SIZE
begin
  GVTurtle.Size := seSize.Value;
  mmoTurtle.Lines.Add(Format('SIZE %d', [seSize.Value]));
end;

procedure TMainFormGVTurtles.btnTowardsClick(Sender: TObject);
// test de TOWARDS
begin
  mmoTurtle.Lines.Add(Format('TOWARDS - X: %d - Y: %d - Résultat: %d',
    [seTowardsX.Value, seTowardsY.Value,
    Round(GVTurtle.Towards(seTowardsX.Value, seTowardsY.Value))]));
end;

procedure TMainFormGVTurtles.btnTurnClick(Sender: TObject);
// test de TURN
begin
  GVTurtle.Turn(seTurn.Value);
  mmoTurtle.Lines.Add(Format('TURN - valeur en degrés: %d', [seTurn.Value]));
end;

procedure TMainFormGVTurtles.btnTurtleVisibleClick(Sender: TObject);
// test de TURTLEVISIBLE
begin
  with GVTurtle do
    TurtleVisible := not TurtleVisible;
  mmoTurtle.Lines.Add('TURTLEVISIBLE - ' + IfThen(GVTurtle.TurtleVisible,
    P_True, P_False));
end;

procedure TMainFormGVTurtles.btnWipeClick(Sender: TObject);
// test de WIPE
begin
  GVTurtle.Wipe;
  mmoTurtle.Lines.Add('WIPE');
end;

procedure TMainFormGVTurtles.FormCreate(Sender: TObject);
// création de la fiche
begin
  // on crée la tortue
  GVTurtle := TGVTurtle.Create(pnlTurtle);
  GVTurtle.Parent := pnlTurtle; // dans le panel
  GVTurtle.OnChange := TurtleState; // gestionnaire de changement
  GVTurtle.OnBeforeChange := TurtleBeforePaint; // idem avant de dessiner
  // on initialise le fond d'écran
  pnlTurtle.ParentBackground := False; // pour le changement du panel
  GVTurtle.OnBackGroundChange := BkgChanged; // gestionnaire de fond
  GVTurtle.ScreenColor := clBlack; // fond noir
end;

procedure TMainFormGVTurtles.FormDestroy(Sender: TObject);
// destruction de la fiche
begin
  GVTurtle.Free;
end;

procedure TMainFormGVTurtles.tbExampleChange(Sender: TObject);
// nouvelle vitesse de la tortue
begin
  GVTurtle.Speed := (100 - tbExample.Position);
  mmoTurtle.Lines.Add('SPEED - ' + IntToStr(GVTurtle.Speed));
  tbExample.Position := GVTurtle.Speed; // indique la nouvelle vitesse
end;

procedure TMainFormGVTurtles.TurtleBeforePaint(Sender: TObject;
  cHeading: Integer);
// image de la tortue avant son affichage
var
  BitM: TBitmap;
begin
  // charge l'image de la tortue
  BitM := TBitmap.Create;
  try
    // les images de la tortue sont proposées tous les 5 degrés
    iTurtle.GetBitmap(Round(GVTurtle.Heading) div 5, BitM);
    // celle qui correspond est assignée au bitmap
    GVTurtle.TurtleImg.Assign(BitM);
  finally
    BitM.Free;
  end;
end;

procedure TMainFormGVTurtles.TurtleState(Sender: TObject;
  cX, cY, cHeading: Integer; cVisible, cDown: Boolean; cColor: TColor);
// état de la tortue
begin
  // données de la tortue
  statusbar.Panels[1].Text := 'X: ' + IntToStr(cX) + ' Y: ' + IntToStr(cY) +
    ' Cap: ' + IntToStr(cHeading) + ' Visible: ' + IfThen(cVisible, P_True,
    P_False) + ' Baissé: ' + IfThen(cDown, P_True, P_False);
end;

end.
