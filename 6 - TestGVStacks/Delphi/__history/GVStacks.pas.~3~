{ |========================================================================|
  |                                                                        |
  |                  G V S O F T                                           |
  |                  Projet : GVLogo                                       |
  |                  Description : Piles                                   |
  |                  Unité : GVStacks.pas                                  |
  |                  Ecrit par  : VASSEUR Gilles                           |
  |                  e-mail : g.vasseur58@laposte.net                      |
  |                  Copyright : © G. VASSEUR                              |
  |                  Date:    21-07-2014 17:17:49                          |
  |                  Version : 2.0.0                                       |
  |                                                                        |
  |========================================================================| }

  {$DEFINE Delphi}
unit GVStacks;

interface

uses
  Classes, SysUtils, Math, GVConsts
  {$IFDEF Delphi}
  , System.Generics.Collections
  {$ENDIF};
type

  { TStack }

  EGVStackException = class(Exception); // erreur
  // événement de la pile
  TGVStackEvent = procedure(Sender: TObject; Action: TGVStackNotification) of object;

  // pile générique

  { TGVStack }

  generic TGVStack<T> = class
  private
    fItems : array of T; // éléments en cours
    fCount : Integer; // nombre d'éléments
    fCapacity : Integer; // capacité actuelle
    fOnNotify : TGVStackEvent; // notification
    procedure Expand; // expansion si nécessaire
    function GetCapacity: Integer; // capacité actuelle
    procedure SetCapacity(const Value: Integer); // fixe la capacité
  protected
    procedure Notify(Action: TGVStackNotification); virtual; // notification
    procedure DoPush(const Value : T); // empilement
    function DoPop : T; // dépilement
  public
    constructor Create; overload; // création
    destructor Destroy; override; // destruction
    procedure Clear; // nettoyage
    procedure Push(const Value : T); // empilement avec notification
    function Pop : T; // dépilement avec notification
    function Peek : T; // sommet de la pile
    procedure Drop; // sommet de la pile éjecté
    procedure Dup;  // duplication au sommet de la pile
    procedure Swap; // inversion au sommet de la pile
    procedure Over; // duplication de l'avant-dernier
    procedure Rot;  // rotation au sommet de la pile
    procedure Shrink; // contraction de la pile
    property Count: Integer read fCount default 0; // compte de éléments
    // capacité de la pile
    property Capacity: Integer read GetCapacity write SetCapacity default CMinStack;
    /// notification d'un changement
    property OnNotify: TGVStackEvent read fOnNotify write fOnNotify;
end;

  // piles spécialisées
  TGVIntegerStack = specialize TGVStack<Integer>;
  TGVRealStack = specialize TGVStack<Real>;
  TGVStringStack = specialize TGVStack<string>;

implementation

{ TGVStack }

procedure TGVStack.Expand;
// *** expansion de la pile ***
var
  LCount : Integer;
begin
  LCount := Length(fItems) shl 1;  // double la capacité
  if LCount < 0 then // débordement !
    raise EGVStackException.Create(ME_OutOfMemory) // erreur
  else
    SetLength(fItems, Max(LCount, CMinStack)); // ajuste la taille de la pile
end;

function TGVStack.GetCapacity: Integer;
// *** renvoi de la capacité de la pile ***
begin
  Result := Length(fItems);
end;

procedure TGVStack.SetCapacity(const Value: Integer);
// *** mise à jour de la capacité de la pile ***
begin
  if Value > Count then
    SetLength(fItems, Value); // ajustement de la valeur
end;

procedure TGVStack.Notify(Action: TGVStackNotification);
// *** exécution de la procédure de notification si elle existe ***
begin
  if Assigned(fOnNotify) then
    fOnNotify(Self, Action);
end;

procedure TGVStack.DoPush(const Value: T);
// *** effectue l'empilement sans notification ***
begin
  if Count = Length(fItems) then // espace rempli ?
      Expand;
    fItems[Count] := Value; // nouvelle valeur stockée
    Inc(fCount); // pointe vers l'élément suivant
end;

function TGVStack.DoPop: T;
// *** effectue le dépilement sans notification ***
begin
  if Count = 0 then
    raise EGVStackException.Create(ME_EmptyStack); // pile vide
  Result := fItems[Count-1]; // on renvoie la valeur
  Dec(fCount); // on ajuste le pointeur
end;

constructor TGVStack.Create;
// *** création de la pile ***
begin
  inherited Create; // on hérite
  fCount := 0;  // pas d'éléments
  fCapacity := CMinStack; // capacité au minimum
  SetLength(fItems, CMInStack); // espace au minimum
end;

destructor TGVStack.Destroy;
// *** destruction de la pile ***
begin
  Clear; // nettoyage
  inherited Destroy; // on hérite
end;

procedure TGVStack.Clear;
// *** nettoyage de la pile ***
begin
  while Count > 0 do // tant qu'il y a des éléments...
    DoPop; // le haut de la pile est enlevé
  SetLength(fItems,CMinStack); // espace au minimum
end;

procedure TGVStack.Push(const Value: T);
// *** empilement d'un nouvel élément ***
begin
  DoPush(Value); // empilement
  Notify(cnAdded); // on notifie le changement
end;

function TGVStack.Pop: T;
// *** renvoi du sommet de la pile en le détruisant ***
begin
  Result := DoPop; // effectue le dépilement
  Notify(cnRemoved); // on notifie le changement
end;

function TGVStack.Peek: T;
// *** renvoi du sommet de la pile avec conservation ***
begin
  if Count = 0 then
    raise EGVStackException.Create(ME_EmptyStack); // pile vide
  Result := FItems[Count-1];
end;

procedure TGVStack.Drop;
// *** retrait du sommet de la pile sans affectation ***
begin
  Pop;
end;

procedure TGVStack.Dup;
// *** duplication du sommet de la pile ***
begin
  Push(Peek);
end;

procedure TGVStack.Swap;
// *** inversion des deux derniers éléments au sommet de la pile ***
var
  LItem1, LItem2 : T;
begin
  if Count < 2 then
    raise EGVStackException.CreateFmt(ME_LowStack,[Count,2]); // pile insuffisante
  LItem1 := DoPop; // on retire deux éléments
  LItem2 := DoPop;
  DoPush(LItem1); // qu'on rempile dans le sens inverse
  DoPush(LItem2);
  Notify(cnChanged); // changement notifié
end;

procedure TGVStack.Over;
// *** duplication de l'avant-dernier élément sur la pile ***
var
  LItem1, LItem2 : T;
begin
  if Count < 2 then
    raise EGVStackException.CreateFmt(ME_LowStack,[Count,2]); // pile insuffisante
  LItem1 := DoPop; // on retire le premier élément
  LItem2 := Peek; // on mémorise le second
  DoPush(LItem1); // on rempile le premier
  DoPush(LItem2); // on rempile le second
  Notify(cnAdded); // changement notifié
end;

procedure TGVStack.Rot;
// *** rotation des trois éléments au sommet de la pile ***
var
  LItem1, LItem2, LItem3 : T;
begin
  if Count < 3 then
    raise EGVStackException.CreateFmt(ME_LowStack,[Count,3]); // pile insuffisante
  LItem1 := DoPop; // on dépile trois éléments
  LItem2 := DoPop;
  LItem3 := DoPop;
  DoPush(LItem2); // on les rempile dans le bon ordre
  DoPush(LItem1);
  DoPush(LItem3);
  NotiFy(cnChanged); // changement notifié
end;

procedure TGVStack.Shrink;
// *** réduction de la taille de la pile ***
begin
  SetLength(fItems,Max(Count,CMinStack)); // longueur ajustée
end;

end.

